# lec9 语法制导的语义计算基础-part2

## Q 基于翻译模式的自下而上语义计算中如何完成把继承属性/综合属性与LR移进-归约分析的分析栈位置的映射

A: 下面是基于一个对二进制小数转十进制小数语义操作的例子进行阐述
```
已知内容：

DEFINE:
ε = epislon, NULL 

## 表示二进制小数的上下文无关文法
Example1：

N -> .  S 
S -> B  S1 
S -> ε 
B -> 0
B -> 1

   |
   V

##  Step1 添加了求值计算对应十机制小数值的语义操作

继承属性：B.f S.f  综合属性: S.v B.v   

对于上例Example1, 扩展为Example2： 
N -> . { S.f : =1}  S   { print(S.v) }
S ->  { B.f : =S.f } B { S1.f := S.f +1 } S1 {S.v := S1.v+B.v } 
S -> ε  { S.v := 0 }
B -> 0  { B.v := 0 }
B -> 1  { B.v := 2^(-B.f) }
   |
   V

##  Step2 继承属性进行模拟求值（即转换为综合属性）

### 模拟求值算法：
继承属性：C.i  M.i,  综合属性:  A.s M.s
S -> a A {C.i:= f(A.s)} C   ==>  S -> a A {M.i := A.s} M {C.i := M.s} C    M -> ε {M.s := f(M.i)}
NOTICE 这里存在复写规则：M.i := A.s， C.i := M.s

### 对于上例Example2，采用模拟求值算法扩展为Example3

继承属性：B.f S.f P.i,  综合属性:  S.v B.v M.s P.s.

N -> . M   { S.f : = M.s }   S   { print(S.v) }
S -> { B.f :=S.f }  B  { P.i :=S.f }  P  { S1.f := P.s }  S1  {S.v := S1.v+B.v } 
S -> ε  { S.v := 0 }
B -> 0  { B.v := 0 }
B -> 1  { B.v := 2^(-B.f) }
M -> ε  { M.s := 1}
P -> ε  { P.s := P.i+1 }

NOTICE 这里存在复写规则：P.i := S.f， S.f : = M.s S1.f := P.s
由于有复写规则，所以，某个继承属性总可以最终归结为某个综合属性。
如， B.f OR P.i:=S.f:=M.s OR P.s  
此时，除了复写规则操作，其他语义操作都是基于综合属性的语义操作

   |
   V

## Step3 把综合属性变量映射到LR分析栈的对应位置中

分析栈与语义栈的关系：二者的堆栈大小和栈顶[top]的位置随时保持相同。

辅助说明：
对产生式 A->αβ，记其产生式右部（即αβ）的语法单位列表长度|αβ|为n。记当前的分析栈中的栈
顶[top]指向产生式右部的最右侧的单个语法单位（可以是一个ε，终结符，非终结符）。

对产生式进行语义执行操作的步骤：
在归约前，记录当前的分析栈/语义栈顶位置为[top]。

1. 计算产生式左部和右部各语法单元的综合属性在语义栈中的位置。
LR分析在进行归约时，会完成出栈入栈，并更新top指针，对于产生式各个语法单位的位置进行计算需要分析其在栈中的地址。
对产生式 A->αβ，出栈会弹出|αβ|长度（设为n，如果右部是ε，则n=0，其他情况，n>1）的元素，并压入1个单位长度
（这是由于要把A.s压入到语义栈中），所以new_top:=old_top-n+1。故对于产生式A->BCD...E  {A.s=function(B.s,C.s,D.s...E.s}，
其对应的栈位置为
[top-n+1].s=function([top-n+1].s, [top-n+2].s,[top-n+3].s,...[top].s])

1.1 如果产生式右部是单个语法单位ε，则在完成本次归约前，分析栈中的栈顶[top]指向下一次要归约的产生式右部（可以是一部分右部）
最右侧-1处的语法单位。一旦完成本次归约，产生式左部将位于栈顶[top+1]位置。原因是在对语法单位ε做出栈操作时，没有弹出任何栈单
元（即top不变）；但入栈时，压入了产生式左部的非终结符（即top+1），所以归约后，[new_top]=[old_top+1]
如，A -> ε    B -> C A ，则在对A -> ε进行归约时，现在语义栈顶[top] = C.s，[top-0+1]= A.s。 

1.2 如果产生式右部是多个语法单位(不包括ε)组成，数量为n(n>0)，则当前语义栈顶[top]=产生式右部最右侧语法元的综合属性，并从右
向左依次递减。出栈时，当前new_top=old_top-n，再接着要入栈，即压入产生式左部的非终结符，所以[old_top-n+1]是产生式左部非终
结符的综合属性的位置[new_top]。
如, A -> Bc  {A.s=fun(B.s,c.s)}，则现在语义栈顶[top] = c.s，[top-1] = B.s，[top-2+1] = A.s

2. 计算产生式右部各语法单元的继承属性在语义栈中的位置。 
即在语义栈中，其实只存在了综合属性，但由于有复写规则，所以，某非终结符的继承属性的值直接或间接地被另外一个非终结符的综合属性代替。
对于综合属性进行计算时，在输入侧会有继承属性存在，如 B -> αβ  { B.s := fun(B.i) }，
在归约后，综合属性B.s的位置为[new_top]即[old_top-1+1]。但B的继承属性B.i的栈位置要依赖复写规则来分析。

如存在复写规则（可以有多个） S -> Aδ {B.i:=A.s } B  则B.i的位置即A.s的位置。这样设δ的位数为m(m>-1)，即在B位置的右侧m-1处
即A.s的位置。所以继承属性B.i的位置为B.s位置-（m-1）处，即[top-m+1]。如果有多个复写规则进行一个复写链，则需要逐个分析，把复写
规则链相关的产生式也链接合并起来，形成 S -> A {M.i:=A.s } M ... {B.i:=M.i } B，找到B和A之间的距离差为t，即为B.i在栈中的
位置=[top-t]  


NOTICE：语义执行操作在语义栈上执行，LR归约在分析栈上执行，二者对各自的栈进行操作，所以不会冲突，且由于在每次LR归约操作/综合属性
操作是同步进行的，且在执行完毕后，由于都执行了同样的出栈和入栈操作，确保了二者的栈顶指针在每个操作前后是相等的。在做LR移入(shift)
操作时，不会涉及综合属性操作.

继承属性：B.f S.f P.i,  综合属性:  S.v B.v M.s P.s.

参照上述转换规则，可得：

N -> . M S                print(val [top] .v) 
S -> B P S1               val [top-2].v := val [top].v + val [top-2].v 
S -> ε                    val [top+1].v := 0 
B -> 0                    val [top].v := 0 
B -> 1                    val [top].v := 2^(-val [top-1].s) 
M -> ε                    val [top+1].s := 1 
P -> ε                    val [top+1].s := val [top-1].s+1

### 对把综合属性变量映射到LR分析栈的对应位置中的举例分析

N -> . M S                print(val [top] .v) 
>> 在对N归约前，分析栈上是 .MS的综合属性，即[top]-->S， [top-1]-->M 且S已经完成了归约，故[top]=S.v

S -> B P S1               val [top-2].v := val [top].v + val [top-2].v 
>> 此产生式右部长度为3,在对S归约前，分析栈上是 BPS1的综合属性，
即[top]-->S1.v，[top-1]-->P.v，[top-2]-->B.v，且S.v是在新的分析栈的栈顶上，
所以[new_top]=[old_top-3+1] ，所以 S.v := S1.v+B.v ==> [top-3+1].v := [top].v + [top-2].v

S -> ε                    val [top+1].v := 0 
>> 在对S归约前，分析栈上的top指向下一个要归约的产生式的右部最右侧S，所以 S.v:= 0 ==> [top-0+1].v:= 0

B -> 1                    val [top].v := 2^(-val [top-1].s) 
>> 在对B归约前，已执行了shift移入操作，所以分析栈上的top指向的是终结符"1"，语义栈上指的是'_'，
然后要把'1'归约为B，B.v在分析栈的new_top上，所以[new_top].v=[old_top-1+1].v=[old_top].v。
而B.f是一个继承属性，我们需要找到其对应的综合属性。根据复写规则，可发现 
B.f:=S.f:=M.s OR B.f:=S.f:=P.s

在对.101进行LR归约的过程中，分析栈和语义栈从（从左向右）Bottom-->Top依次放的是 '. M  1'和 '_ 1 _'
此时，需要进行 B -> 1 的归约操作，对应的语义操作为 B.v := 2^(-B.f) 
B.v为综合属性，所以其位置为[old_top-1+1]=[top]

记 产生式（0）B -> 1   { B.v := 2^(-B.f) }
B.s为继承属性，所以进一步查找保护 {B.s:=...}的产生式，发现有
产生式（1） S -> { B.f :=S.f }  B ....
所以当前已经完成了对继承属性S.f的赋值，在归约B前需要执行对继承属性B.f:=S.f的复写规则。
而当前的语义栈中其实已经存在了继承属性S.f的值了，S.f的值是基于如下产生式的复写规则得到的。
产生式（2）N -> . M   { S.f : = M.s }   S ...
产生式（3）M -> ε  { M.s := 1}

所以，我们可知存在复写规则链 B.f:=S.f:=M.s=1，而在分析栈和语义栈从（从左向右）Bottom-->Top依次放的是 '. M  1'和 '_ 1 _'
'. M  1'是产生式  N -> . M  S归约过程的某一步，更加对应的语义栈'_ 1 _'，可知M.s=1
另外，把复写规则链相关的产生式也链接起来，会发现
N -> . M   { S.f : = M.s }   S  -> . M   { S.f : = M.s }  { B.f :=S.f }  B ... 
可知B的位置与M的位置只差1。所以M.s在分析栈中的位置为[top-1]





## 进行SLR(1)的语法归约分析和语义操作

### 形成 SLR(1)

State	 .   0	           1	          $                  N     M     S     B     P
-------------------------------------------------------------------------------------
0    shift(2)                                              1
1			                             accept
2        reduce(M → ε) reduce(M → ε)  reduce(M → ε)              3
3	      shift(4)      shift(5)       reduce(S → ε)                    6     7
4	      reduce(B → 0) reduce(B → 0)  reduce(B → 0)
5	      reduce(B → 1) reduce(B → 1)  reduce(B → 1)
6	                      		        reduce(N → o M S)
7	      reduce(P → ε) reduce(P → ε)  reduce(P → ε)                                 8
8	      shift(4)       shift(5)      reduce(S → ε)                     9     7
9				                          reduce(S → B P S)
--------------------------------------------------------------------------------------
(分析存放分析过程中的文法符号，语义栈存放分析过程中的文法符号的综合属性，top为栈顶指针)

```
